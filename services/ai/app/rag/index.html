<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>RAG Assistant — Streaming Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <style>
    /* tiny extra styling */
    body { background: #f7fafc; }
    .bubble { white-space: pre-wrap; word-break: break-word; }
    .user { background:#2563eb; color:white; }
    .assistant { background:#eef2ff; color:#0f172a; }
  </style>
</head>
<body>
  <div id="app" class="max-w-2xl mx-auto p-4">
    <h1 class="text-2xl font-semibold mb-4">RAG Assistant (Streaming)</h1>

    <div class="border rounded-lg bg-white shadow-sm p-4 flex flex-col" style="height:70vh;">
      <div ref="scrollArea" class="overflow-auto mb-4" style="flex:1 1 auto;">
        <div v-for="(m, idx) in messages" :key="idx" class="mb-3">
          <div :class="['inline-block px-4 py-2 rounded-2xl bubble', m.role === 'user' ? 'user' : 'assistant']"
               :style="m.role === 'user' ? 'margin-left:auto' : ''">
            <div v-if="m.role==='assistant' && m.streaming">
              <em class="text-sm text-gray-500">typing…</em>
            </div>
            <div v-html="formatMessage(m.content)"></div>
          </div>
        </div>
      </div>

      <div class="flex items-center gap-2">
        <input v-model="query" @keydown.enter.prevent="send" placeholder="Ask a question..." 
               class="flex-1 border rounded px-3 py-2" />
        <button @click="send" :disabled="isStreaming || !query.trim()" class="px-4 py-2 bg-indigo-600 text-white rounded">
          Send
        </button>
        <button v-if="isStreaming" @click="cancel" class="px-3 py-2 border rounded text-sm">Cancel</button>
      </div>

      <div class="text-xs text-gray-500 mt-2">Streaming via fetch & ReadableStream. Make sure backend CORS allows this origin.</div>
    </div>
  </div>

  <script>
  const { createApp, ref, onMounted } = Vue;

  createApp({
    data() {
      return {
        query: "",
        messages: [
          { role: "assistant", content: "Hello — ask me anything about the FAQs.", streaming: false }
        ],
        controller: null,
        isStreaming: false,
      };
    },
    methods: {
      formatMessage(text) {
        // simple markup for URLs and newlines
        if (!text) return "";
        const esc = text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        return esc.replace(/\n/g, "<br/>");
      },

      async send() {
        const q = this.query.trim();
        if (!q || this.isStreaming) return;

        // add user message
        this.messages.push({ role: "user", content: q, streaming: false });
        // add assistant placeholder
        const assistantIndex = this.messages.push({ role: "assistant", content: "", streaming: true }) - 1;

        // clear input and set streaming state
        this.query = "";
        this.isStreaming = true;

        // Setup abort controller so we can cancel
        this.controller = new AbortController();
        const signal = this.controller.signal;

        try {
          // Replace the fetch URL in send() method
            const res = await fetch("http://localhost:8000/api/v1/stream", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query: q }),
            signal,
            });


          if (!res.ok) {
            const text = await res.text();
            this.messages[assistantIndex].content = `Error: ${res.status} ${text}`;
            this.messages[assistantIndex].streaming = false;
            this.isStreaming = false;
            this.scrollToBottom();
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            // server is sending SSE-style chunks: "data: {...}\n\n"
            // split on double newline (may yield partial pieces)
            let parts = buffer.split("\n\n");
            // keep last (possibly partial) chunk in buffer
            buffer = parts.pop();

            for (const part of parts) {
              if (!part.trim()) continue;
              // match "data: <json>" (could be multiple data: lines; we take last)
              const lines = part.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              for (const line of lines) {
                if (line.startsWith("data:")) {
                  const payload = line.replace(/^data:\s*/, "");
                  try {
                    const parsed = JSON.parse(payload);
                    // parsed.chunk expected
                    this.appendAssistantChunk(assistantIndex, parsed.chunk);
                  } catch (e) {
                    // if not JSON, append raw
                    this.appendAssistantChunk(assistantIndex, payload);
                  }
                } else {
                  // if no "data:" prefix, just append line
                  this.appendAssistantChunk(assistantIndex, line);
                }
              }
            }
            this.scrollToBottom();
          }

          // flush remaining buffer (in case server didn't end with \n\n)
          if (buffer && buffer.trim()) {
            // attempt to parse any remaining data lines
            const m = buffer.match(/data:\s*(.*)/s);
            if (m) {
              try {
                const parsed = JSON.parse(m[1]);
                this.appendAssistantChunk(assistantIndex, parsed.chunk);
              } catch {
                this.appendAssistantChunk(assistantIndex, m[1]);
              }
            } else {
              this.appendAssistantChunk(assistantIndex, buffer);
            }
          }

        } catch (err) {
          if (err.name === "AbortError") {
            this.appendAssistantChunk(assistantIndex, "\n\n[Stream cancelled]");
          } else {
            this.appendAssistantChunk(assistantIndex, `\n\n[Stream error] ${err.message || err}`);
          }
        } finally {
          this.messages[assistantIndex].streaming = false;
          this.isStreaming = false;
          this.controller = null;
          this.scrollToBottom();
        }
      },

      appendAssistantChunk(index, chunk) {
        // create or append to assistant message content
        if (typeof chunk !== "string") chunk = String(chunk);
        const cur = this.messages[index].content || "";
        this.messages[index].content = cur + chunk;
      },

      cancel() {
        if (this.controller) {
          this.controller.abort();
        }
      },

      scrollToBottom() {
        this.$nextTick(() => {
          const el = this.$refs.scrollArea;
          if (el) el.scrollTop = el.scrollHeight + 100;
        });
      }
    },
    mounted() {
      this.scrollToBottom();
    }
  }).mount("#app");
  </script>
</body>
</html>
