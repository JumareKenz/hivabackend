"""
QueryWeaver Service - Integration with QueryWeaver for NL2SQL
QueryWeaver uses graph-based schema understanding for accurate SQL generation
"""
import httpx
import asyncio
from typing import Dict, Any, Optional, List
from app.core.config import settings


class QueryWeaverService:
    """
    Service for integrating with QueryWeaver NL2SQL engine.
    QueryWeaver provides graph-powered schema understanding for better SQL generation.
    """
    
    def __init__(self):
        # QueryWeaver configuration
        self.base_url = getattr(settings, "QUERYWEAVER_URL", "http://localhost:5000")
        self.enabled = getattr(settings, "USE_QUERYWEAVER", False)
        self.timeout = 30.0
        self._client: Optional[httpx.AsyncClient] = None
    
    async def initialize(self):
        """Initialize QueryWeaver client"""
        if not self.enabled:
            return
        
        self._client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=self.timeout
        )
        
        # Test connection
        try:
            response = await self._client.get("/health")
            if response.status_code == 200:
                print("✅ QueryWeaver connected")
            else:
                print(f"⚠️ QueryWeaver health check returned {response.status_code}")
        except Exception as e:
            print(f"⚠️ QueryWeaver not available: {e}")
            print("   Falling back to enhanced SQL generator")
            self.enabled = False
    
    async def generate_sql(
        self,
        natural_language_query: str,
        schema_context: Optional[Dict[str, Any]] = None,
        conversation_history: Optional[List[Dict[str, Any]]] = None
    ) -> Dict[str, Any]:
        """
        Generate SQL using QueryWeaver.
        
        Args:
            natural_language_query: User's natural language query
            schema_context: Optional schema context
            conversation_history: Optional conversation history
        
        Returns:
            Dictionary with:
            - sql: Generated SQL query
            - explanation: Explanation of the query
            - confidence: Confidence score
            - source: "queryweaver"
        """
        if not self.enabled or not self._client:
            return {
                "sql": None,
                "explanation": "QueryWeaver not available",
                "confidence": 0.0,
                "source": "queryweaver",
                "error": "QueryWeaver service not enabled or unavailable"
            }
        
        try:
            # Prepare request payload
            payload = {
                "query": natural_language_query,
                "schema_context": schema_context or {},
                "conversation_history": conversation_history or []
            }
            
            # Call QueryWeaver API
            response = await self._client.post(
                "/api/generate-sql",
                json=payload
            )
            
            if response.status_code == 200:
                result = response.json()
                return {
                    "sql": result.get("sql"),
                    "explanation": result.get("explanation", "Query generated by QueryWeaver"),
                    "confidence": result.get("confidence", 0.8),
                    "source": "queryweaver",
                    "queryweaver_metadata": result.get("metadata", {})
                }
            else:
                return {
                    "sql": None,
                    "explanation": f"QueryWeaver returned error: {response.status_code}",
                    "confidence": 0.0,
                    "source": "queryweaver",
                    "error": response.text
                }
        
        except httpx.TimeoutException:
            return {
                "sql": None,
                "explanation": "QueryWeaver request timed out",
                "confidence": 0.0,
                "source": "queryweaver",
                "error": "Timeout"
            }
        except Exception as e:
            return {
                "sql": None,
                "explanation": f"QueryWeaver error: {str(e)}",
                "confidence": 0.0,
                "source": "queryweaver",
                "error": str(e)
            }
    
    async def validate_sql(self, sql: str) -> Dict[str, Any]:
        """
        Validate SQL query using QueryWeaver.
        
        Args:
            sql: SQL query to validate
        
        Returns:
            Validation result
        """
        if not self.enabled or not self._client:
            return {"valid": False, "error": "QueryWeaver not available"}
        
        try:
            response = await self._client.post(
                "/api/validate-sql",
                json={"sql": sql}
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                return {"valid": False, "error": f"Validation failed: {response.status_code}"}
        
        except Exception as e:
            return {"valid": False, "error": str(e)}
    
    async def explain_sql(self, sql: str) -> str:
        """
        Get explanation of SQL query from QueryWeaver.
        
        Args:
            sql: SQL query to explain
        
        Returns:
            Explanation text
        """
        if not self.enabled or not self._client:
            return "QueryWeaver not available"
        
        try:
            response = await self._client.post(
                "/api/explain-sql",
                json={"sql": sql}
            )
            
            if response.status_code == 200:
                result = response.json()
                return result.get("explanation", "No explanation available")
            else:
                return f"Could not get explanation: {response.status_code}"
        
        except Exception as e:
            return f"Error getting explanation: {str(e)}"
    
    async def close(self):
        """Close QueryWeaver client"""
        if self._client:
            await self._client.aclose()


# Global instance
queryweaver_service = QueryWeaverService()

